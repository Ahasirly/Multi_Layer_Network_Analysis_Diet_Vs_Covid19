# === Install and load required packages ===
library(tidyverse)
library(igraph)
library(scales)
library(readr)

# === Import data ===
# Protein supply data (relative to repository root)
protein_data <- read_csv(file.path("data", "Protein_Supply_Quantity_Data.csv"))

# Economic data (store Countries.csv in data/ to keep paths portable)
econ_path <- file.path("data", "Countries.csv")
econ_raw <- read.csv(econ_path, stringsAsFactors = FALSE)

# === Data preprocessing (dietary network analysis) ===
# Extract numeric dietary data (exclude non-dietary indicators)
numeric_data <- protein_data %>%
  select(-`Unit (all except Population)`, -Population, -Obesity, -Undernourished,
         -Confirmed, -Deaths, -Recovered, -Active) %>%
  column_to_rownames("Country")

# Standardize and construct network
mat <- as.matrix(numeric_data)
mat_norm <- scale(mat)

# =============================
# ① Network analysis based on Pearson correlation coefficient
# =============================
sim_cor <- cor(t(mat_norm))  # Calculate dietary pattern correlation between countries
threshold_cor <- 0.6
adj_cor <- sim_cor
adj_cor[adj_cor < threshold_cor] <- 0  # Filter low correlation values
g <- graph_from_adjacency_matrix(adj_cor, mode = "undirected", weighted = TRUE, diag = FALSE)

# Calculate network indicators
deg <- degree(g)
btw <- betweenness(g)
comm <- cluster_louvain(g)  # Louvain community detection

# Output basic network information
cat("==== Network based on Pearson Correlation ====\n")
cat("Average degree: ", mean(deg), "\n")
cat("Number of communities: ", length(unique(membership(comm))), "\n")
cat("Top 10 countries by betweenness centrality:\n")
print(sort(btw, decreasing = TRUE)[1:10])

# Visualize the network
plot(
  g,
  vertex.size = rescale(deg, to = c(5, 15)),
  vertex.color = membership(comm),
  vertex.label = NA,
  edge.width = rescale(E(g)$weight, to = c(0.2, 2)),
  main = "National Dietary Pattern Network (Pearson Similarity > 0.6)"
)

# Extract community information (clean country names)
country_clusters <- data.frame(
  Country = trimws(names(membership(comm))),  # Standardize country names by trimming whitespace
  Community = membership(comm),
  stringsAsFactors = FALSE
)

# Output countries in each community
cat("\nCountries in each community (Pearson similarity network):\n")
for (c in sort(unique(country_clusters$Community))) {
  cat(paste0("\n[Community ", c, "]\n"))
  cat(paste(country_clusters$Country[country_clusters$Community == c], collapse = ", "))
  cat("\n")
}

# =============================
# ② Integrate health, COVID-19 and economic data
# =============================
# 1. Health data (obesity and undernourishment rates)
health_data <- protein_data %>%
  select(Country, Obesity, Undernourished) %>%
  mutate(
    Country = trimws(Country),
    Obesity = parse_number(as.character(Obesity)),
    Undernourished = parse_number(as.character(Undernourished))
  )

# 2. COVID-19 data (convert to per 100 people indicators)
covid_data <- protein_data %>%
  # Keep unit column for judgment (will be excluded later)
  select(Country, Confirmed, Deaths, Recovered, Active, Population, `Unit (all except Population)`) %>%
  mutate(
    Country = trimws(Country),
    across(c(Confirmed, Deaths, Recovered, Active, Population), as.numeric),
    # Convert to per 100 people based on unit
    infection_rate = ifelse(
      grepl("%", `Unit (all except Population)`),
      Confirmed,  # Already in percentage
      Confirmed / Population * 100  # Convert raw cases to percentage
    ),
    death_rate = ifelse(
      grepl("%", `Unit (all except Population)`),
      Deaths,
      Deaths / Population * 100
    ),
    recovery_rate = ifelse(
      grepl("%", `Unit (all except Population)`),
      Recovered,
      Recovered / Population * 100
    ),
    active_rate = ifelse(
      grepl("%", `Unit (all except Population)`),
      Active,
      Active / Population * 100
    )
  ) %>%
  # Exclude unnecessary columns (unit column has served its purpose)
  select(Country, infection_rate, death_rate, recovery_rate, active_rate)

# 3. Economic data (year 2022)
econ_2022 <- econ_raw %>%
  filter(Year == 2022) %>%
  select(
    Country = Country.Name,
    GDP,
    GDP_per_cap = GDP.Per.Capita,
    Agriculture = Agriculture....GDP.,
    Industry = Industry....GDP.,
    Service = Service....GDP.,
    Health_exp = Health.Expenditure....GDP.,
    Education_exp = Education.Expenditure....GDP.
  ) %>%
  mutate(Country = trimws(Country))  # Standardize country name format

# =============================
# ③ Unified data merging and community filtering
# =============================
# Merge all data (community + health + COVID-19 + economy)
all_merged <- country_clusters %>%
  left_join(health_data, by = "Country") %>%
  left_join(covid_data, by = "Country") %>%
  left_join(econ_2022, by = "Country") %>%
  filter(!is.na(Community))  # Exclude countries without community classification

# Filter top 5 communities with complete data (core step: ensure consistent communities across all analyses)
valid_communities <- all_merged %>%
  # Exclude communities with missing key indicators
  filter(
    !is.na(Obesity), 
    !is.na(infection_rate), 
    !is.na(GDP)
  ) %>%
  pull(Community) %>%
  unique() %>%
  sort() %>%  # Sort by community number
  head(5)  # Take top 5 valid communities

# Filter data based on valid communities
analysis_data <- all_merged %>%
  filter(Community %in% valid_communities) %>%
  mutate(Community = factor(Community, levels = valid_communities))  # Fix community order

# =============================
# ④ Indicator summary by community
# =============================
community_summary <- analysis_data %>%
  group_by(Community) %>%
  summarise(
    n_countries = n(),
    # Health indicators
    mean_obesity = mean(Obesity, na.rm = TRUE),
    mean_undernourished = mean(Undernourished, na.rm = TRUE),
    # COVID-19 indicators
    mean_infection = mean(infection_rate, na.rm = TRUE),
    mean_death = mean(death_rate, na.rm = TRUE),
    mean_recovery = mean(recovery_rate, na.rm = TRUE),
    # Economic indicators
    mean_GDP = mean(GDP, na.rm = TRUE),
    mean_GDP_per_cap = mean(GDP_per_cap, na.rm = TRUE),
    mean_agri = mean(Agriculture, na.rm = TRUE),
    mean_industry = mean(Industry, na.rm = TRUE),
    mean_service = mean(Service, na.rm = TRUE)
  )

cat("\n===== Community Comprehensive Indicator Summary =====\n")
print(community_summary)

# =============================
# ⑤ Visualization with unified community order
# =============================
# 1. Health indicators comparison
health_long <- community_summary %>%
  select(Community, mean_obesity, mean_undernourished) %>%
  pivot_longer(
    cols = -Community,
    names_to = "metric",
    values_to = "value"
  ) %>%
  mutate(
    metric = recode(metric,
                    mean_obesity = "Obesity Rate (%)",
                    mean_undernourished = "Undernourished Rate (%)"
    )
  )

ggplot(health_long, aes(x = Community, y = value, fill = metric)) +
  geom_col(position = "dodge", width = 0.7) +
  geom_text(
    aes(label = round(value, 1)),
    position = position_dodge(0.7),
    vjust = -0.3,
    size = 3.5
  ) +
  labs(title = "Health Indicators Comparison (Top 5 Communities)", x = "Community", y = "Average Value (%)", fill = "") +
  theme_minimal() +
  ylim(0, max(health_long$value) * 1.2)

# 2. COVID-19 indicators comparison
covid_long <- community_summary %>%
  select(Community, mean_infection, mean_death, mean_recovery) %>%
  pivot_longer(
    cols = -Community,
    names_to = "metric",
    values_to = "value"
  ) %>%
  mutate(
    metric = recode(metric,
                    mean_infection = "Infection Rate (%)",
                    mean_death = "Death Rate (%)",
                    mean_recovery = "Recovery Rate (%)"
    )
  )

ggplot(covid_long, aes(x = Community, y = value, fill = metric)) +
  geom_col(position = "dodge", width = 0.7) +
  geom_text(
    aes(label = round(value, 2)),
    position = position_dodge(0.7),
    vjust = -0.3,
    size = 3.5
  ) +
  labs(title = "COVID-19 Indicators Comparison (Top 5 Communities)", x = "Community", y = "Per 100 People (%)", fill = "") +
  theme_minimal() +
  ylim(0, max(covid_long$value) * 1.2)

# 3. GDP comparison alone (consistent with integrated chart)
ggplot(community_summary, aes(x = Community, y = mean_GDP)) +
  geom_col(fill = "steelblue", width = 0.7) +
  geom_text(
    aes(label = scales::comma(round(mean_GDP, 0))),
    vjust = -0.3,
    size = 3.5
  ) +
  labs(title = "Average GDP Comparison (Top 5 Communities, 2022)", x = "Community", y = "GDP") +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma)  # Convert scientific notation to readable format

# 4. Economic structure comparison
econ_struct_long <- community_summary %>%
  select(Community, mean_agri, mean_industry, mean_service) %>%
  pivot_longer(
    cols = -Community,
    names_to = "sector",
    values_to = "value"
  ) %>%
  mutate(
    sector = recode(sector,
                    mean_agri = "Agriculture",
                    mean_industry = "Industry",
                    mean_service = "Service"
    )
  )

ggplot(econ_struct_long, aes(x = Community, y = value, fill = sector)) +
  geom_col(width = 0.7) +
  geom_text(
    aes(label = round(value, 1)),
    position = position_stack(vjust = 0.5),
    size = 3
  ) +
  labs(title = "Economic Structure Comparison (Top 5 Communities)", x = "Community", y = "% of GDP", fill = "") +
  theme_minimal()



# 5. Integrated indicator chart (with GDP scaling) and summary information
combined_long <- community_summary %>%
  select(Community, mean_GDP, mean_infection, mean_death, mean_recovery, mean_obesity) %>%
  pivot_longer(
    cols = -Community,
    names_to = "metric",
    values_to = "value"
  ) %>%
  mutate(
    metric = recode(metric,
                    mean_GDP = "GDP (scaled)",
                    mean_infection = "Infection Rate (%)",
                    mean_death = "Death Rate (%)",
                    mean_recovery = "Recovery Rate (%)",
                    mean_obesity = "Obesity Rate (%)"
    ),
    # GDP scaling (adjust divisor based on data range for better visualization)
    value_scaled = ifelse(metric == "GDP (scaled)", value / 1e11, value)  # Scaling factor can be adjusted based on actual data
  )

# Print numerical summary of integrated chart
cat("\n===== Integrated Chart Data Summary (Corresponding to Chart) =====\n")
print(combined_long %>%
        select(Community, metric, value_scaled) %>%
        pivot_wider(names_from = metric, values_from = value_scaled) %>%
        arrange(Community) %>%
        mutate(across(where(is.numeric), ~round(., 2)))  # Keep 2 decimal places
)

# Plot integrated chart
ggplot(combined_long, aes(x = Community, y = value_scaled, fill = metric)) +
  geom_col(width = 0.7) +
  geom_text(
    aes(label = round(value_scaled, 2)),
    vjust = -0.3,
    size = 3.5
  ) +
  facet_wrap(~metric, scales = "free_y", ncol = 3) +
  labs(title = "Comprehensive Community Indicators (GDP Scaled)", x = "Community", y = "Value") +
  theme_minimal() +
  theme(legend.position = "none")

